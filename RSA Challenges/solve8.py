#!/usr/bin/env python

n = 23516695565660963250242846975094031309572348962900032827958534374248114661507001374384417953124930587796472484525315334716723068326965228898857733318407681656604325744994115789416012096318656034667361976251100005599211469354510367804546831680730445574797161330145320706346512982316782618118878428893337849886890813813050423818145497040676697510093220374542784895778086554812954376689653727580227087363619223145837820593375994747273662064715654881379557354513619477314410917942381406981452545764657853425675230343749326640073923166795823683203941972393206970228647854927797483660176460658959810390117898333516129469397
e = 3
ciphertext = 145069245024457407970388457302568525045688441508350620445553303097210529802020156842534271527464635050860748816803790910853366771838992303776518246009397475087259557220229739272919078824096942593663260736405547321937692016524108920147672998393440513476061602816076372323775207700936797148289812069641665092971298180210327453380160362030493

# Many attempts and OverflowErrors later, a better solution...
def get_m(C):

    # Find length of m = C ^ (1/e)
    m = "1" + "".join("0" for x in range(len(str(C))) if pow(int("1" + "0" * x), e) < C)

    # Enumerate m = C ^ (1/e)
    for y in range(len(m)):
        M = m[:y], m[y+1:]
        for x in range(1, 10):
            tmp = int(str(x).join(M))
            if tmp ** e < C:
                m = str(x).join(M)
            elif tmp ** e > C:
                m = str(x - 1).join(M)
                break
            else:
                return tmp

m = get_m(ciphertext)

print(bytes.fromhex(hex(m)[2:]).decode())
